// Copyright (c) 2015, Daniel Mart√≠ <mvdan@mvdan.cc>
// See LICENSE for licensing information

package main

import (
	"fmt"
	"go/importer"
	"go/types"
	"io"
	"os"
	"text/template"
)

const filename = "std.go"

var tmpl = template.Must(template.New("std").Parse(`// Generated by generate/std

package main

var pkgs = map[string][]string{
{{range $pkg, $names := .}}	"{{$pkg}}": {
{{range $_, $name := $names}}		"{{$name}}",
{{end}}	},
{{end}}}
`))

func fromScope(scope *types.Scope) []string {
	var wanted []string
	for _, name := range scope.Names() {
		tn, ok := scope.Lookup(name).(*types.TypeName)
		if !ok {
			continue
		}
		switch x := tn.Type().Underlying().(type) {
		case *types.Interface:
			if x.NumMethods() == 0 {
				continue
			}
		case *types.Signature:
		default:
			continue
		}
		wanted = append(wanted, name)
	}
	return wanted
}

func generate(w io.Writer) error {
	imp := importer.Default()
	fromScope(types.Universe)
	wanted := make(map[string][]string)
	for _, path := range pkgs {
		pkg, err := imp.Import(path)
		if err != nil {
			return err
		}
		names := fromScope(pkg.Scope())
		if names == nil {
			continue
		}
		wanted[path] = names
	}
	return tmpl.Execute(w, wanted)
}

func main() {
	f, err := os.Create(filename)
	if err != nil {
		errExit(err)
	}
	defer f.Close()
	if err := generate(f); err != nil {
		errExit(err)
	}
}

func errExit(err error) {
	fmt.Fprintf(os.Stderr, "%v\n", err)
	os.Exit(1)
}
